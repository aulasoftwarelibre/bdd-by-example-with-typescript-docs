{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BDD by example with TypeScript \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de Ciaran McNulty : TDD with PhpSpec Driving Design through Examples Versi\u00f3n en PHP: https://github.com/aulasoftwarelibre/bdd-by-example-docs/ Agradecimientos \u00b6 Este taller ha sido impartido por las siguientes personas: Javier Ca\u00f1ete (Versi\u00f3n PHP) Sergio G\u00f3mez (Versi\u00f3n PHP y TypeScript)","title":"Inicio"},{"location":"#bdd-by-example-with-typescript","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de Ciaran McNulty : TDD with PhpSpec Driving Design through Examples Versi\u00f3n en PHP: https://github.com/aulasoftwarelibre/bdd-by-example-docs/","title":"BDD by example with TypeScript"},{"location":"#agradecimientos","text":"Este taller ha sido impartido por las siguientes personas: Javier Ca\u00f1ete (Versi\u00f3n PHP) Sergio G\u00f3mez (Versi\u00f3n PHP y TypeScript)","title":"Agradecimientos"},{"location":"fifth-scenario/","text":"Quinto escenario \u00b6 Vamos a implementar el \u00faltimo escenario 1 2 3 4 5 6 7 8 Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Si ejecutamos la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn cucumber features/menu.feature:43 ..P------..P------ Warnings: 1 ) Scenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | ? Dado que he comprado 1 men\u00fa del n\u00famero 1 # step-definitions/menu.steps.ts:67 Pending - Y que he comprado 2 men\u00fas del n\u00famero 2 # step-definitions/menu.steps.ts:27 - Y que he comprado 2 men\u00fas del n\u00famero 3 # step-definitions/menu.steps.ts:27 - Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 - Y pago en efectivo con 55 euros # step-definitions/menu.steps.ts:43 - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:47 - Y he obtenido 50 puntos # step-definitions/menu.steps.ts:51 1 scenario ( 1 pending ) 8 steps ( 1 pending, 6 skipped, 1 passed ) 0m00.001s Falla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de men\u00fas . Al ser frases distintas behat las interpreta como pasos distintos. Necesitamos conseguir que un mismo paso se ejecute con sentencias distintas. Por lo pronto el c\u00f3digo siguiente: 1 2 3 4 5 6 7 Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Que pertenece a nuestro step-definitions/menu.steps.ts sobra y lo eliminamos. Escribir las reglas como expresiones regulares \u00b6 Cambiamos el snippet que nos gener\u00f3 cucumber para crear una expresi\u00f3n regular que soporte la frase en plural y en singular: 1 2 3 4 5 6 7 8 9 Given ( /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); En el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n. Estado final \u00b6 Vamos a poner el c\u00f3digo del step-definitions/menu.steps.ts : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( ammount : number ) { bill . payWithMoney ( ammount * 100 ); }); Then ( \"la factura est\u00e1 pagada\" , function () { expect ( bill . restToPay ()). to . equal ( 0 ); }); Then ( \"he obtenido {int} puntos\" , function ( points : number ) { expect ( bill . points ()). to . equal ( points ); }); When ( \"pago con {int} puntos y {int} euros\" , function ( points : number , money : number ) { bill . payWithMoney ( money * 100 ); bill . payWithPoints ( points ); }); Then ( \"quedan {int} euros por pagar\" , function ( amount : number ) { expect ( amount * 100 ). to . equal ( bill . restToPay ()); }); Y ejecutamos, ahora s\u00ed, todas las pruebas: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature ........................................................................ 5 scenarios ( 5 passed ) 31 steps ( 31 passed ) 0m00.007s Done in 1 .94s. Podemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.","title":"Quinto escenario"},{"location":"fifth-scenario/#quinto-escenario","text":"Vamos a implementar el \u00faltimo escenario 1 2 3 4 5 6 7 8 Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Si ejecutamos la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn cucumber features/menu.feature:43 ..P------..P------ Warnings: 1 ) Scenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | ? Dado que he comprado 1 men\u00fa del n\u00famero 1 # step-definitions/menu.steps.ts:67 Pending - Y que he comprado 2 men\u00fas del n\u00famero 2 # step-definitions/menu.steps.ts:27 - Y que he comprado 2 men\u00fas del n\u00famero 3 # step-definitions/menu.steps.ts:27 - Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 - Y pago en efectivo con 55 euros # step-definitions/menu.steps.ts:43 - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:47 - Y he obtenido 50 puntos # step-definitions/menu.steps.ts:51 1 scenario ( 1 pending ) 8 steps ( 1 pending, 6 skipped, 1 passed ) 0m00.001s Falla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de men\u00fas . Al ser frases distintas behat las interpreta como pasos distintos. Necesitamos conseguir que un mismo paso se ejecute con sentencias distintas. Por lo pronto el c\u00f3digo siguiente: 1 2 3 4 5 6 7 Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Que pertenece a nuestro step-definitions/menu.steps.ts sobra y lo eliminamos.","title":"Quinto escenario"},{"location":"fifth-scenario/#escribir-las-reglas-como-expresiones-regulares","text":"Cambiamos el snippet que nos gener\u00f3 cucumber para crear una expresi\u00f3n regular que soporte la frase en plural y en singular: 1 2 3 4 5 6 7 8 9 Given ( /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); En el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n.","title":"Escribir las reglas como expresiones regulares"},{"location":"fifth-scenario/#estado-final","text":"Vamos a poner el c\u00f3digo del step-definitions/menu.steps.ts : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( ammount : number ) { bill . payWithMoney ( ammount * 100 ); }); Then ( \"la factura est\u00e1 pagada\" , function () { expect ( bill . restToPay ()). to . equal ( 0 ); }); Then ( \"he obtenido {int} puntos\" , function ( points : number ) { expect ( bill . points ()). to . equal ( points ); }); When ( \"pago con {int} puntos y {int} euros\" , function ( points : number , money : number ) { bill . payWithMoney ( money * 100 ); bill . payWithPoints ( points ); }); Then ( \"quedan {int} euros por pagar\" , function ( amount : number ) { expect ( amount * 100 ). to . equal ( bill . restToPay ()); }); Y ejecutamos, ahora s\u00ed, todas las pruebas: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature ........................................................................ 5 scenarios ( 5 passed ) 31 steps ( 31 passed ) 0m00.007s Done in 1 .94s. Podemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.","title":"Estado final"},{"location":"first-scenario/","text":"Implementando el primer escenario \u00b6 El primer escenario es el siguiente: 1 2 3 4 5 6 Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Para implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta ( Bill ) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos. Describir la clase Bill \u00b6 Vamos a definir nuestra clase src/restaurant/bill.ts : 1 2 3 class Bill {} export default Bill ; y la especificaci\u00f3n ssrc/restaurant/bill.spec.ts : 1 2 3 4 5 6 7 8 9 import Bill from \"./bill\" ; describe ( \"Bill\" , () => { let bill = new Bill (); it ( \"is initializable\" , () => { expect ( bill ). toBeInstanceOf ( Bill ); }); }); Ahora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para: A\u00f1adir un men\u00fa a la cuenta Obtener el total de la cuenta Permitir pagar una cantidad de dinero Determinar cu\u00e1nto resta por pagar Determinar cu\u00e1ntos puntos se han ganado Para esta prueba vamos a suponer que tenemos ya una instancia de Menu que cuesta 10\u20ac. A\u00f1adiendo elementos a la cuenta \u00b6 Nuestro objetivo es a\u00f1adir el precio de los men\u00fas a la cuenta. Para eso vamos a suponer que tenemos un men\u00fa que vale 10\u20ac. Vamos a crear ese men\u00fa de ejemplo en nuestra especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { mocked } from \"ts-jest/utils\" ; import Bill from \"./bill\" ; import Menu from \"./menu\" ; jest . mock ( \"./menu\" ); describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mocked ( Menu ); beforeEach (() => { menu . mockClear (); menu . prototype . price = jest . fn (). mockReturnValue ( 1000 ); }); }); En esta ocasi\u00f3n no estamos usando beforeEach para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de la clase Menu y que cuando se llamen a la funci\u00f3n price() devolver\u00e1 1000. Hay que tener en cuenta que Menu no es algo que hayamos instanciado nosotros. Lo que ha ocurrido es que jest ha creado un doble o mock , una clase que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas mockReturnValue . Completamos la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { mocked } from \"ts-jest/utils\" ; import Bill from \"./bill\" ; import Menu from \"./menu\" ; jest . mock ( \"./menu\" ); describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mocked ( Menu ); beforeEach (() => { menu . mockClear (); menu . prototype . price = jest . fn (). mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu . prototype ); expect ( bill . total ()). toBe ( 1100 ); }); }); Estamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Menu from \"./menu\" ; class Bill { private readonly VAT = 1.1 ; private items : Menu []; constructor () { this . items = []; } add ( menu : Menu ) : void { this . items . push ( menu ); } total () : number { return ( this . VAT * this . items . reduce (( carry : number , item : Menu ) => carry + item . price (), 0 ) ); } } export default Bill ; Y ejecutamos las pruebas: 1 2 3 4 5 6 7 8 9 10 11 12 $ yarn test yarn run v1.22.0 $ jest PASS src/restaurant/menu.spec.ts PASS src/restaurant/bill.spec.ts Test Suites: 2 passed, 2 total Tests: 4 passed, 4 total Snapshots: 0 total Time: 1.701s, estimated 3s Ran all test suites. Done in 3.00s. Refactorizar Menu \u00b6 A la clase Bill, \u00bfle importa el n\u00famero del men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz Priced que obligue a las clases que lo implementen a devolver price() . De esa manera, a Bill solo le interesa que elemento que a\u00f1adimos a la cuenta tenga un m\u00e9todo price . Vamos a crear nuestro interfaz Priced en src/restaurant/priced.ts : 1 2 3 4 5 interface Priced { price () : number ; } export default Priced ; Ahora necesitamos que nuestra clase Menu implemente la interfaz Priced : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Priced from \"./priced\" ; class Menu implements Priced { constructor ( private _option : number , private _price : number ) {} option () : number { return this . _option ; } price () : number { return this . _price ; } } export default Menu ; Refactorizamos la especificaci\u00f3n de Bill: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { mock , mockReset } from \"jest-mock-extended\" ; import Bill from \"./bill\" ; import Priced from \"./priced\" ; describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mock < Priced > (); beforeEach (() => { mockReset ( menu ); menu . price . mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu ); expect ( bill . total ()). toBe ( 1100 ); }); }); Y refactorizamos la clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; constructor () { this . items = []; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return ( this . VAT * this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ) ); } } export default Bill ; Implementando los primeros steps \u00b6 Ahora estamos en posici\u00f3n de implementar los primeros steps: 1 2 3 4 5 6 Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Quedando el c\u00f3digo en el archivo step-definitions/menu.steps.ts como sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Y comprobamos que, efectivamente, el c\u00f3digo funciona: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ yarn cucumber features/menu.feature:16 ....P--....P-- Warnings: 1 ) Scenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 ? Y pago en efectivo con 55 euros # step-definitions/menu.steps.ts:43 Pending - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:49 - Y he obtenido 50 puntos # step-definitions/menu.steps.ts:54 1 scenario ( 1 pending ) 6 steps ( 1 pending, 2 skipped, 3 passed ) 0m00.003s Implementando el pago \u00b6 Para implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido. Esta ser\u00eda la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import { mock , mockReset } from \"jest-mock-extended\" ; import Bill from \"./bill\" ; import Priced from \"./priced\" ; describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mock < Priced > (); beforeEach (() => { bill = new Bill (); mockReset ( menu ); menu . price . mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu ); expect ( bill . total ()). toBe ( 1100 ); }); it ( \"can be paid with money\" , () => { bill . add ( menu ); bill . payWithMoney ( 1100 ); expect ( bill . restToPay ()). toBe ( 0 ); }); it ( \"can give points when is payed with money\" , () => { bill . add ( menu ); bill . payWithMoney ( 1100 ); expect ( bill . points ()). toBe ( 10 ); }); it ( \"cannot give points when total is not enough\" , () => { const otherMenu = mock < Priced > (); otherMenu . price . mockReturnValue ( 99 ); bill . add ( otherMenu ); bill . payWithMoney ( 109 ); expect ( bill . points ()). toBe ( 0 ); }); }); Estamos describiendo distintos casos: Cuando se paga exacto y no queda nada por pagar Cuando se pagan justo 10 euros Cuando se pagan menos de 1 euro Podr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes. Completamos el c\u00f3digo en la clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; constructor () { this . items = []; this . committed = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } restToPay () : number { return this . total () - this . committed ; } points () : number { return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } } export default Bill ; Y comprobamos que pasamos las pruebas: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ yarn test yarn run v1.22.0 $ jest PASS src/restaurant/menu.spec.ts PASS src/restaurant/bill.spec.ts Test Suites: 2 passed, 2 total Tests: 7 passed, 7 total Snapshots: 0 total Time: 1 .01s Ran all test suites. Done in 2 .36s. Ya nos resta terminar de implementar la historia de usuario. Nuestra clase step-definitions/menu.steps.ts queda as\u00ed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( ammount : number ) { bill . payWithMoney ( ammount * 100 ); }); Then ( \"la factura est\u00e1 pagada\" , function () { expect ( bill . restToPay ()). to . equal ( 0 ); }); Then ( \"he obtenido {int} puntos\" , function ( points : number ) { expect ( bill . points ()). to . equal ( points ); }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Si ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:16 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.003s Done in 1 .85s.","title":"Implementando el primer escenario"},{"location":"first-scenario/#implementando-el-primer-escenario","text":"El primer escenario es el siguiente: 1 2 3 4 5 6 Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Para implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta ( Bill ) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos.","title":"Implementando el primer escenario"},{"location":"first-scenario/#describir-la-clase-bill","text":"Vamos a definir nuestra clase src/restaurant/bill.ts : 1 2 3 class Bill {} export default Bill ; y la especificaci\u00f3n ssrc/restaurant/bill.spec.ts : 1 2 3 4 5 6 7 8 9 import Bill from \"./bill\" ; describe ( \"Bill\" , () => { let bill = new Bill (); it ( \"is initializable\" , () => { expect ( bill ). toBeInstanceOf ( Bill ); }); }); Ahora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para: A\u00f1adir un men\u00fa a la cuenta Obtener el total de la cuenta Permitir pagar una cantidad de dinero Determinar cu\u00e1nto resta por pagar Determinar cu\u00e1ntos puntos se han ganado Para esta prueba vamos a suponer que tenemos ya una instancia de Menu que cuesta 10\u20ac.","title":"Describir la clase Bill"},{"location":"first-scenario/#anadiendo-elementos-a-la-cuenta","text":"Nuestro objetivo es a\u00f1adir el precio de los men\u00fas a la cuenta. Para eso vamos a suponer que tenemos un men\u00fa que vale 10\u20ac. Vamos a crear ese men\u00fa de ejemplo en nuestra especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { mocked } from \"ts-jest/utils\" ; import Bill from \"./bill\" ; import Menu from \"./menu\" ; jest . mock ( \"./menu\" ); describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mocked ( Menu ); beforeEach (() => { menu . mockClear (); menu . prototype . price = jest . fn (). mockReturnValue ( 1000 ); }); }); En esta ocasi\u00f3n no estamos usando beforeEach para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de la clase Menu y que cuando se llamen a la funci\u00f3n price() devolver\u00e1 1000. Hay que tener en cuenta que Menu no es algo que hayamos instanciado nosotros. Lo que ha ocurrido es que jest ha creado un doble o mock , una clase que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas mockReturnValue . Completamos la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { mocked } from \"ts-jest/utils\" ; import Bill from \"./bill\" ; import Menu from \"./menu\" ; jest . mock ( \"./menu\" ); describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mocked ( Menu ); beforeEach (() => { menu . mockClear (); menu . prototype . price = jest . fn (). mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu . prototype ); expect ( bill . total ()). toBe ( 1100 ); }); }); Estamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Menu from \"./menu\" ; class Bill { private readonly VAT = 1.1 ; private items : Menu []; constructor () { this . items = []; } add ( menu : Menu ) : void { this . items . push ( menu ); } total () : number { return ( this . VAT * this . items . reduce (( carry : number , item : Menu ) => carry + item . price (), 0 ) ); } } export default Bill ; Y ejecutamos las pruebas: 1 2 3 4 5 6 7 8 9 10 11 12 $ yarn test yarn run v1.22.0 $ jest PASS src/restaurant/menu.spec.ts PASS src/restaurant/bill.spec.ts Test Suites: 2 passed, 2 total Tests: 4 passed, 4 total Snapshots: 0 total Time: 1.701s, estimated 3s Ran all test suites. Done in 3.00s.","title":"A\u00f1adiendo elementos a la cuenta"},{"location":"first-scenario/#refactorizar-menu","text":"A la clase Bill, \u00bfle importa el n\u00famero del men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz Priced que obligue a las clases que lo implementen a devolver price() . De esa manera, a Bill solo le interesa que elemento que a\u00f1adimos a la cuenta tenga un m\u00e9todo price . Vamos a crear nuestro interfaz Priced en src/restaurant/priced.ts : 1 2 3 4 5 interface Priced { price () : number ; } export default Priced ; Ahora necesitamos que nuestra clase Menu implemente la interfaz Priced : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Priced from \"./priced\" ; class Menu implements Priced { constructor ( private _option : number , private _price : number ) {} option () : number { return this . _option ; } price () : number { return this . _price ; } } export default Menu ; Refactorizamos la especificaci\u00f3n de Bill: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import { mock , mockReset } from \"jest-mock-extended\" ; import Bill from \"./bill\" ; import Priced from \"./priced\" ; describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mock < Priced > (); beforeEach (() => { mockReset ( menu ); menu . price . mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu ); expect ( bill . total ()). toBe ( 1100 ); }); }); Y refactorizamos la clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; constructor () { this . items = []; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return ( this . VAT * this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ) ); } } export default Bill ;","title":"Refactorizar Menu"},{"location":"first-scenario/#implementando-los-primeros-steps","text":"Ahora estamos en posici\u00f3n de implementar los primeros steps: 1 2 3 4 5 6 Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Quedando el c\u00f3digo en el archivo step-definitions/menu.steps.ts como sigue: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Y comprobamos que, efectivamente, el c\u00f3digo funciona: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ yarn cucumber features/menu.feature:16 ....P--....P-- Warnings: 1 ) Scenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 ? Y pago en efectivo con 55 euros # step-definitions/menu.steps.ts:43 Pending - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:49 - Y he obtenido 50 puntos # step-definitions/menu.steps.ts:54 1 scenario ( 1 pending ) 6 steps ( 1 pending, 2 skipped, 3 passed ) 0m00.003s","title":"Implementando los primeros steps"},{"location":"first-scenario/#implementando-el-pago","text":"Para implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido. Esta ser\u00eda la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import { mock , mockReset } from \"jest-mock-extended\" ; import Bill from \"./bill\" ; import Priced from \"./priced\" ; describe ( \"Bill\" , () => { let bill = new Bill (); let menu = mock < Priced > (); beforeEach (() => { bill = new Bill (); mockReset ( menu ); menu . price . mockReturnValue ( 1000 ); }); it ( \"has no items by default\" , () => { expect ( bill . total ()). toBe ( 0 ); }); it ( \"add an item\" , () => { bill . add ( menu ); expect ( bill . total ()). toBe ( 1100 ); }); it ( \"can be paid with money\" , () => { bill . add ( menu ); bill . payWithMoney ( 1100 ); expect ( bill . restToPay ()). toBe ( 0 ); }); it ( \"can give points when is payed with money\" , () => { bill . add ( menu ); bill . payWithMoney ( 1100 ); expect ( bill . points ()). toBe ( 10 ); }); it ( \"cannot give points when total is not enough\" , () => { const otherMenu = mock < Priced > (); otherMenu . price . mockReturnValue ( 99 ); bill . add ( otherMenu ); bill . payWithMoney ( 109 ); expect ( bill . points ()). toBe ( 0 ); }); }); Estamos describiendo distintos casos: Cuando se paga exacto y no queda nada por pagar Cuando se pagan justo 10 euros Cuando se pagan menos de 1 euro Podr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes. Completamos el c\u00f3digo en la clase Bill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; constructor () { this . items = []; this . committed = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } restToPay () : number { return this . total () - this . committed ; } points () : number { return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } } export default Bill ; Y comprobamos que pasamos las pruebas: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ yarn test yarn run v1.22.0 $ jest PASS src/restaurant/menu.spec.ts PASS src/restaurant/bill.spec.ts Test Suites: 2 passed, 2 total Tests: 7 passed, 7 total Snapshots: 0 total Time: 1 .01s Ran all test suites. Done in 2 .36s. Ya nos resta terminar de implementar la historia de usuario. Nuestra clase step-definitions/menu.steps.ts queda as\u00ed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import { expect } from \"chai\" ; import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Bill from \"../src/restaurant/bill\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; let bill : Bill ; Before (() => { menus = []; bill = new Bill (); }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( units : number , option : number ) { const menu = menus [ option ]; for ( let i = 0 ; i < units ; i ++ ) { bill . add ( menu ); } }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( total : number ) { expect ( bill . total ()). to . equal ( total * 100 ); }); When ( \"pago en efectivo con {int} euros\" , function ( ammount : number ) { bill . payWithMoney ( ammount * 100 ); }); Then ( \"la factura est\u00e1 pagada\" , function () { expect ( bill . restToPay ()). to . equal ( 0 ); }); Then ( \"he obtenido {int} puntos\" , function ( points : number ) { expect ( bill . points ()). to . equal ( points ); }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Si ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:16 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.003s Done in 1 .85s.","title":"Implementando el pago"},{"location":"fourth-scenario/","text":"Cuarto escenario \u00b6 Vamos a implementar el cuarto escenario 1 2 3 4 5 Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Si ejecutamos la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ yarn cucumber features/menu.feature:37 yarn run v1.22.0 $ ./node_modules/cucumber/bin/cucumber-js features/**/*.feature --require-module ts-node/register --require 'step-definitions/**/*.ts' features/menu.feature:37 .....P.....P Warnings: 1 ) Scenario: Intentar pagar el IVA con puntos # features/menu.feature:37 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 \u2714 Y pago con 550 puntos y 0 euros # step-definitions/menu.steps.ts:55 ? Entonces quedan 5 euros por pagar # step-definitions/menu.steps.ts:63 Pending 1 scenario ( 1 pending ) 5 steps ( 1 pending, 4 passed ) 0m00.002s En esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el step-definitions/menu.steps.ts y ver si nuestra clase funciona: 1 2 3 4 5 // ... Then ( \"quedan {int} euros por pagar\" , function ( amount : number ) { expect ( amount * 100 ). to . equal ( bill . restToPay ()); }); Ejecutamos de nuevo la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $ yarn cucumber features/menu.feature:37 .....F.....F Failures: 1 ) Scenario: Intentar pagar el IVA con puntos # features/menu.feature:37 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 \u2714 Y pago con 550 puntos y 0 euros # step-definitions/menu.steps.ts:55 \u2716 Entonces quedan 5 euros por pagar # step-definitions/menu.steps.ts:63 AssertionError + expected - actual -500 +0 at World.<anonymous> ( /home/sergio/Developer/aulasoftwarelibre/bdd-by-example-typescript/step-definitions/menu.steps.ts:64:27 ) 1 scenario ( 1 failed ) 5 steps ( 1 failed, 4 passed ) 0m00.003s El escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en src/restaurant/bill.spec.ts para tener en cuenta este comportamiento. 1 2 3 4 5 it ( \"cannot pay VAT with points\" , () => { bill . add ( menu ); bill . payWithPoints ( 110 ); expect ( bill . restToPay ()). toBe ( 100 ); }); Y modificamos nuestra clase Bill para pasar la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; private usedPoints : number ; constructor () { this . items = []; this . committed = 0 ; this . usedPoints = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } payWithPoints ( amount : number ) : void { this . usedPoints = amount ; } restToPay () : number { return this . total () - this . committed - this . moneyPoints (); } points () : number { if ( this . usedPoints > 0 ) { return 0 ; } return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } private moneyPoints () : number { const maxMoneyPoints = this . totalBeforeVAT (); const moneyPoints = ( 100 * this . usedPoints ) / 10 ; return moneyPoints > maxMoneyPoints ? maxMoneyPoints : moneyPoints ; } } export default Bill ; Y comprobamos que esto consigue que la prueba pase: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:37 ............ 1 scenario ( 1 passed ) 5 steps ( 5 passed ) 0m00.002s Done in 1 .89s.","title":"Cuarto escenario"},{"location":"fourth-scenario/#cuarto-escenario","text":"Vamos a implementar el cuarto escenario 1 2 3 4 5 Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Si ejecutamos la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ yarn cucumber features/menu.feature:37 yarn run v1.22.0 $ ./node_modules/cucumber/bin/cucumber-js features/**/*.feature --require-module ts-node/register --require 'step-definitions/**/*.ts' features/menu.feature:37 .....P.....P Warnings: 1 ) Scenario: Intentar pagar el IVA con puntos # features/menu.feature:37 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 \u2714 Y pago con 550 puntos y 0 euros # step-definitions/menu.steps.ts:55 ? Entonces quedan 5 euros por pagar # step-definitions/menu.steps.ts:63 Pending 1 scenario ( 1 pending ) 5 steps ( 1 pending, 4 passed ) 0m00.002s En esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el step-definitions/menu.steps.ts y ver si nuestra clase funciona: 1 2 3 4 5 // ... Then ( \"quedan {int} euros por pagar\" , function ( amount : number ) { expect ( amount * 100 ). to . equal ( bill . restToPay ()); }); Ejecutamos de nuevo la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $ yarn cucumber features/menu.feature:37 .....F.....F Failures: 1 ) Scenario: Intentar pagar el IVA con puntos # features/menu.feature:37 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 \u2714 Y pago con 550 puntos y 0 euros # step-definitions/menu.steps.ts:55 \u2716 Entonces quedan 5 euros por pagar # step-definitions/menu.steps.ts:63 AssertionError + expected - actual -500 +0 at World.<anonymous> ( /home/sergio/Developer/aulasoftwarelibre/bdd-by-example-typescript/step-definitions/menu.steps.ts:64:27 ) 1 scenario ( 1 failed ) 5 steps ( 1 failed, 4 passed ) 0m00.003s El escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en src/restaurant/bill.spec.ts para tener en cuenta este comportamiento. 1 2 3 4 5 it ( \"cannot pay VAT with points\" , () => { bill . add ( menu ); bill . payWithPoints ( 110 ); expect ( bill . restToPay ()). toBe ( 100 ); }); Y modificamos nuestra clase Bill para pasar la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; private usedPoints : number ; constructor () { this . items = []; this . committed = 0 ; this . usedPoints = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } payWithPoints ( amount : number ) : void { this . usedPoints = amount ; } restToPay () : number { return this . total () - this . committed - this . moneyPoints (); } points () : number { if ( this . usedPoints > 0 ) { return 0 ; } return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } private moneyPoints () : number { const maxMoneyPoints = this . totalBeforeVAT (); const moneyPoints = ( 100 * this . usedPoints ) / 10 ; return moneyPoints > maxMoneyPoints ? maxMoneyPoints : moneyPoints ; } } export default Bill ; Y comprobamos que esto consigue que la prueba pase: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:37 ............ 1 scenario ( 1 passed ) 5 steps ( 5 passed ) 0m00.002s Done in 1 .89s.","title":"Cuarto escenario"},{"location":"introduction/","text":"Introducci\u00f3n \u00b6 Desarrollo orientado a pruebas (TDD) \u00b6 Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos. Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad. Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba. Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en TypeScript podemos usar Jest. Ciclo del desarrollo orientado a pruebas \u00b6 A\u00f1ade un test Ejecuta los test y comprueba que el nuevo test falla Escribe el c\u00f3digo Ejecuta los test Refactoriza el c\u00f3digo Repite Ejemplo de un test de unidad con Jest \u00b6 Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con Jest, escribir\u00edamos para implementar la funcionalidad suma : 1 2 3 4 5 6 7 8 9 import Calculator from './calculator' ; describe ( 'Create a Calculator' , () => { test ( 'adds zeros' , () => { const calculator = new Calculator (); expect ( calculator . add ( 0 , 0 )). toBe ( 0 ); }); }); Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo: 1 2 3 4 5 6 7 class Calculator { add ( a : number , b : number ) : number { return 0 ; } } export default Calculator ; Evidentemente el c\u00f3digo es el estrictamente necesario para pasar la prueba, pero no todo el necesario para cumplir con la especificaci\u00f3n de la operaci\u00f3n suma. Las pruebas tambi\u00e9n se deben ir escribiendo poco a poco siguiendo las tres reglas. Las tres reglas \u00b6 Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD: No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle. No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile. No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente. Desarrollo orientado a comportamiento (BDD) \u00b6 Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Ciclo del desarrollo orientado a comportamiento \u00b6 Describe el comportamiento del software a trav\u00e9s de pruebas Ejecuta los test y comprueba que el nuevo test falla Implementa el nuevo comportamiento Ejecuta los test Mejora el c\u00f3digo Repite Ejemplo de un test con Cucumber \u00b6 Cucumber utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin: 1 2 3 4 5 6 7 Caracter\u00edstica: Crear una calculadora Escenario: Sumar dos n\u00fameros Dado que quiero sumar dos n\u00fameros Cuando introduzco el n\u00famero 2 E introduzco el n\u00famero 3 Entonces recibo el n\u00famero 5 Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.","title":"Introducci\u00f3n"},{"location":"introduction/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"introduction/#desarrollo-orientado-a-pruebas-tdd","text":"Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos. Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad. Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba. Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en TypeScript podemos usar Jest.","title":"Desarrollo orientado a pruebas (TDD)"},{"location":"introduction/#ciclo-del-desarrollo-orientado-a-pruebas","text":"A\u00f1ade un test Ejecuta los test y comprueba que el nuevo test falla Escribe el c\u00f3digo Ejecuta los test Refactoriza el c\u00f3digo Repite","title":"Ciclo del desarrollo orientado a pruebas"},{"location":"introduction/#ejemplo-de-un-test-de-unidad-con-jest","text":"Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con Jest, escribir\u00edamos para implementar la funcionalidad suma : 1 2 3 4 5 6 7 8 9 import Calculator from './calculator' ; describe ( 'Create a Calculator' , () => { test ( 'adds zeros' , () => { const calculator = new Calculator (); expect ( calculator . add ( 0 , 0 )). toBe ( 0 ); }); }); Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo: 1 2 3 4 5 6 7 class Calculator { add ( a : number , b : number ) : number { return 0 ; } } export default Calculator ; Evidentemente el c\u00f3digo es el estrictamente necesario para pasar la prueba, pero no todo el necesario para cumplir con la especificaci\u00f3n de la operaci\u00f3n suma. Las pruebas tambi\u00e9n se deben ir escribiendo poco a poco siguiendo las tres reglas.","title":"Ejemplo de un test de unidad con Jest"},{"location":"introduction/#las-tres-reglas","text":"Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD: No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle. No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile. No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.","title":"Las tres reglas"},{"location":"introduction/#desarrollo-orientado-a-comportamiento-bdd","text":"Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n.","title":"Desarrollo orientado a comportamiento (BDD)"},{"location":"introduction/#ciclo-del-desarrollo-orientado-a-comportamiento","text":"Describe el comportamiento del software a trav\u00e9s de pruebas Ejecuta los test y comprueba que el nuevo test falla Implementa el nuevo comportamiento Ejecuta los test Mejora el c\u00f3digo Repite","title":"Ciclo del desarrollo orientado a comportamiento"},{"location":"introduction/#ejemplo-de-un-test-con-cucumber","text":"Cucumber utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin: 1 2 3 4 5 6 7 Caracter\u00edstica: Crear una calculadora Escenario: Sumar dos n\u00fameros Dado que quiero sumar dos n\u00fameros Cuando introduzco el n\u00famero 2 E introduzco el n\u00famero 3 Entonces recibo el n\u00famero 5 Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.","title":"Ejemplo de un test con Cucumber"},{"location":"modelling/","text":"Modelando con ejemplos \u00b6 Captura de requisitos \u00b6 Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos. Por ejemplo, veamos que ocurre cuando especificamos solo con reglas: Example RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa. RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa. RF03 : El IVA es del 10%. El problema es que nos surgen una serie de dudas que estas reglas no resuelven: \u00bfSi gasto puntos a\u00fan puedo ganar puntos? \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa? \u00bfEl IVA se aplica al precio descontado o al total? Si modelamos los requisitos con ejemplos obtenemos esto: Example Si un men\u00fa para una familia de cinco personas cuesta 50 euros: Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos. Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas. Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin. Gherkin \u00b6 Gherkin es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con gherkin debe ir en un fichero con extensi\u00f3n .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # language: es Caracter\u00edstica: Internal operations In order to stay secret As a secret organization We need to be able to erase past agents' memory Antecedentes: [Dados|Dadas|Dada|Dado|*] there is agent A [*|Y|E] there is agent B Escenario: Erasing agent memory [Dados|Dadas|Dada|Dado|*] there is agent J [*|Y|E] there is agent K [Cuando|*] I erase agent K's memory [Entonces|*] there should be agent J [Pero|*] there should not be agent K Esquema del escenario: Erasing other agents' memory [Dados|Dadas|Dada|Dado|*] there is agent <agent1> [*|Y|E] there is agent <agent2> [Cuando|*] I erase agent <agent2>'s memory [Entonces|*] there should be agent <agent1> [Pero|*] there should not be agent <agent2> Ejemplos: | agent1 | agent2 | | D | M | Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial. Introducci\u00f3n de la caracter\u00edstica \u00b6 Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave Caracter\u00edstica seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla. Los antecedentes son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes. Los escenarios son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones: \" Dado unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba. \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar. \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente. Se pueden concatenar sentencias con las palabras Y , E y PERO , tal y como se ve en la plantilla. Creando los escenarios \u00b6 Vamos a describir un posible archivo gherkin para nuestro ejemplo del restaurante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.","title":"Modelando con ejemplos"},{"location":"modelling/#modelando-con-ejemplos","text":"","title":"Modelando con ejemplos"},{"location":"modelling/#captura-de-requisitos","text":"Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos. Por ejemplo, veamos que ocurre cuando especificamos solo con reglas: Example RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa. RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa. RF03 : El IVA es del 10%. El problema es que nos surgen una serie de dudas que estas reglas no resuelven: \u00bfSi gasto puntos a\u00fan puedo ganar puntos? \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa? \u00bfEl IVA se aplica al precio descontado o al total? Si modelamos los requisitos con ejemplos obtenemos esto: Example Si un men\u00fa para una familia de cinco personas cuesta 50 euros: Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos. Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas. Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.","title":"Captura de requisitos"},{"location":"modelling/#gherkin","text":"Gherkin es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con gherkin debe ir en un fichero con extensi\u00f3n .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # language: es Caracter\u00edstica: Internal operations In order to stay secret As a secret organization We need to be able to erase past agents' memory Antecedentes: [Dados|Dadas|Dada|Dado|*] there is agent A [*|Y|E] there is agent B Escenario: Erasing agent memory [Dados|Dadas|Dada|Dado|*] there is agent J [*|Y|E] there is agent K [Cuando|*] I erase agent K's memory [Entonces|*] there should be agent J [Pero|*] there should not be agent K Esquema del escenario: Erasing other agents' memory [Dados|Dadas|Dada|Dado|*] there is agent <agent1> [*|Y|E] there is agent <agent2> [Cuando|*] I erase agent <agent2>'s memory [Entonces|*] there should be agent <agent1> [Pero|*] there should not be agent <agent2> Ejemplos: | agent1 | agent2 | | D | M | Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.","title":"Gherkin"},{"location":"modelling/#introduccion-de-la-caracteristica","text":"Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave Caracter\u00edstica seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla. Los antecedentes son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes. Los escenarios son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones: \" Dado unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba. \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar. \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente. Se pueden concatenar sentencias con las palabras Y , E y PERO , tal y como se ve en la plantilla.","title":"Introducci\u00f3n de la caracter\u00edstica"},{"location":"modelling/#creando-los-escenarios","text":"Vamos a describir un posible archivo gherkin para nuestro ejemplo del restaurante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.","title":"Creando los escenarios"},{"location":"second-scenario/","text":"Segundo escenario \u00b6 Vamos a implementar ahora el segundo escenario 1 2 3 4 5 6 Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn cucumber features/menu.feature:23 yarn run v1.22.0 $ ./node_modules/cucumber/bin/cucumber-js features/**/*.feature --require-module ts-node/register --require 'step-definitions/**/*.ts' features/menu.feature:23 ....P--....P-- Warnings: 1 ) Scenario: Pagar con dinero y puntos # features/menu.feature:23 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 ? Y pago con 10 puntos y 54 euros # step-definitions/menu.steps.ts:55 Pending - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:47 - Y he obtenido 0 puntos # step-definitions/menu.steps.ts:51 1 scenario ( 1 pending ) 6 steps ( 1 pending, 2 skipped, 3 passed ) 0m00.001s Solo tenemos que implementar el pago con puntos. Describir la funcionalidad \u00b6 El primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase Bill : 1 2 3 4 5 6 7 8 // ... it ( \"can be paid with money and points and get no points\" , () => { bill . add ( menu ); bill . payWithMoney ( 1000 ); bill . payWithPoints ( 10 ); expect ( bill . restToPay ()). toBe ( 0 ); expect ( bill . points ()). toBe ( 0 ); }); Refactorizamos nuestro c\u00f3digo para pasar la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; private usedPoints : number ; constructor () { this . items = []; this . committed = 0 ; this . usedPoints = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } payWithPoints ( amount : number ) : void { this . usedPoints = amount ; } restToPay () : number { return this . total () - this . committed - this . moneyPoints (); } points () : number { if ( this . usedPoints > 0 ) { return 0 ; } return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } private moneyPoints () : number { return 100 * ( this . usedPoints / 10 ); } } export default Bill ; Comprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario. Completando la historia de usuario \u00b6 Creamos el c\u00f3digo que implementa el paso que nos falta: 1 2 3 4 5 6 7 8 9 //... When ( \"pago con {int} puntos y {int} euros\" , function ( points : number , money : number ) { bill . payWithMoney ( money * 100 ); bill . payWithPoints ( points ); }); Y ya hemos conseguido terminar otro escenario: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:23 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.004s Done in 1 .89s. Conclusiones \u00b6 Como vamos viendo, el c\u00f3digo que se genera en jest es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En cucumber solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases ( Menu y Bill ) trabajan bien juntas.","title":"Segundo escenario"},{"location":"second-scenario/#segundo-escenario","text":"Vamos a implementar ahora el segundo escenario 1 2 3 4 5 6 Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn cucumber features/menu.feature:23 yarn run v1.22.0 $ ./node_modules/cucumber/bin/cucumber-js features/**/*.feature --require-module ts-node/register --require 'step-definitions/**/*.ts' features/menu.feature:23 ....P--....P-- Warnings: 1 ) Scenario: Pagar con dinero y puntos # features/menu.feature:23 \u2714 Before # step-definitions/menu.steps.ts:10 \u2714 Dados los siguientes men\u00fas: # step-definitions/menu.steps.ts:15 | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | \u2714 Dado que he comprado 5 men\u00fas del n\u00famero 1 # step-definitions/menu.steps.ts:27 \u2714 Cuando pido la cuenta recibo una factura de 55 euros # step-definitions/menu.steps.ts:37 ? Y pago con 10 puntos y 54 euros # step-definitions/menu.steps.ts:55 Pending - Entonces la factura est\u00e1 pagada # step-definitions/menu.steps.ts:47 - Y he obtenido 0 puntos # step-definitions/menu.steps.ts:51 1 scenario ( 1 pending ) 6 steps ( 1 pending, 2 skipped, 3 passed ) 0m00.001s Solo tenemos que implementar el pago con puntos.","title":"Segundo escenario"},{"location":"second-scenario/#describir-la-funcionalidad","text":"El primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase Bill : 1 2 3 4 5 6 7 8 // ... it ( \"can be paid with money and points and get no points\" , () => { bill . add ( menu ); bill . payWithMoney ( 1000 ); bill . payWithPoints ( 10 ); expect ( bill . restToPay ()). toBe ( 0 ); expect ( bill . points ()). toBe ( 0 ); }); Refactorizamos nuestro c\u00f3digo para pasar la prueba: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import Priced from \"./priced\" ; class Bill { private readonly VAT = 1.1 ; private items : Priced []; private committed : number ; private usedPoints : number ; constructor () { this . items = []; this . committed = 0 ; this . usedPoints = 0 ; } add ( item : Priced ) : void { this . items . push ( item ); } total () : number { return this . VAT * this . totalBeforeVAT (); } payWithMoney ( amount : number ) : void { this . committed = amount ; } payWithPoints ( amount : number ) : void { this . usedPoints = amount ; } restToPay () : number { return this . total () - this . committed - this . moneyPoints (); } points () : number { if ( this . usedPoints > 0 ) { return 0 ; } return Math . floor ( this . totalBeforeVAT () / 100 ); } private totalBeforeVAT () : number { return this . items . reduce ( ( carry : number , item : Priced ) => carry + item . price (), 0 ); } private moneyPoints () : number { return 100 * ( this . usedPoints / 10 ); } } export default Bill ; Comprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario.","title":"Describir la funcionalidad"},{"location":"second-scenario/#completando-la-historia-de-usuario","text":"Creamos el c\u00f3digo que implementa el paso que nos falta: 1 2 3 4 5 6 7 8 9 //... When ( \"pago con {int} puntos y {int} euros\" , function ( points : number , money : number ) { bill . payWithMoney ( money * 100 ); bill . payWithPoints ( points ); }); Y ya hemos conseguido terminar otro escenario: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:23 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.004s Done in 1 .89s.","title":"Completando la historia de usuario"},{"location":"second-scenario/#conclusiones","text":"Como vamos viendo, el c\u00f3digo que se genera en jest es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En cucumber solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases ( Menu y Bill ) trabajan bien juntas.","title":"Conclusiones"},{"location":"start-project/","text":"Crear el proyecto \u00b6 Vamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de una plantilla ya preparada. Abrimos la siguiente direcci\u00f3n: https://github.com/aulasoftwarelibre/bdd-typescript-template . Y pulsamos el bot\u00f3n \"Use this template\" para crear un nuevo repositorio basado en \u00e9l. Clonamos el repositorio en nuestro equipo e instalamos las dependencias con yarn install . Creaci\u00f3n de caracter\u00edsticas \u00b6 Las caracter\u00edsticas (ficheros .feature ) deben ir dentro del directorio features/ de nuestro proyecto. Tip Las cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo. Crearemos dentro de dicho directorio un fichero llamado menu.feature con el contenido que describimos en el cap\u00edtulo anterior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Ejecuci\u00f3n de cucumber \u00b6 Ahora que tenemos las pruebas definidas vamos a ejecutar cucumber : 1 yarn cucumber Obtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n: 1 2 3 5 scenarios ( 5 undefined ) 31 steps ( 31 undefined ) 0m00.000s Lo que significa es que cucumber no reconoce ninguno de los step o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello cucumber nos facilita el trabajo con una serie de snippets . Veamos uno: 1 2 3 4 5 6 7 8 <? php Given ( 'que he comprado {int} men\u00fas del n\u00famero {int}' , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return 'pending' ; }); El step se compone de una cabecera con las palabras Given , When o Then y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa cucumber . Si creamos el archivo step-definitions/menu.steps.ts , lo usaremos para introducir todos los snippets que nos ha generado el int\u00e9rprete. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import { Given , Then , When } from \"cucumber\" ; Given ( \"los siguientes men\u00fas:\" , function ( dataTable ) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( int ) { // When('pido la cuenta recibo una factura de {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Si volvemos a ejecutar behat: 1 yarn cucumber Obtenemos algo distinto: 1 2 3 5 scenarios ( 5 pending ) 31 steps ( 5 pending, 26 skipped ) 0m00.001s Ya los escenarios no est\u00e1n como undefined sino como pending . Implementando el primer step \u00b6 El primer step es el que corresponde con la parte de antecedentes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Que corresponde al siguiente snippet 1 2 3 4 5 6 import { Given , Then , When } from \"cucumber\" ; Given ( \"los siguientes men\u00fas:\" , function ( dataTable ) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Y aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas. Jest \u00b6 Jest es un framework de pruebas para Javascript.Principalmente lo que vamos a indicar con jest es la API de nuestra clase con el resto del dominio. Por el momento, para poder pasar la prueba que falla \"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de jest . Creamos los siguientes ficheros: 1 2 3 4 // src/restaurant/menu.ts class Menu {} export default Menu ; 1 2 3 4 5 6 7 8 9 10 //src/restaurant/menu.spec.ts import Menu from \"./menu\" ; describe ( \"Menu class\" , () => { let menu = new Menu (); it ( \"is initializable\" , () => { expect ( menu ). toBeInstanceOf ( Menu ); }); }); Ejecutamos las pruebas y obtenemos lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ yarn test yarn run v1.17.3 $ jest PASS src/restaurant/menu.spec.ts Menu class \u2713 it is initializable (3ms) Test Suites: 1 passed, 1 total Tests: 1 passed, 1 total Snapshots: 0 total Time: 1.409s, estimated 2s Ran all test suites. Done in 2.01s. Vamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro menu.spec.ts : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import Menu from \"./menu\" ; describe ( \"Menu class\" , () => { const OPTION = 10 ; const PRICE = 2500 ; let menu : Menu ; beforeEach (() => { menu = new Menu ( OPTION , PRICE ); }); it ( \"has a menu option number\" , () => { expect ( menu . option ()). toBe ( OPTION ); }); it ( \"has a price\" , () => { expect ( menu . price ()). toBe ( PRICE ); }); }); Las l\u00edneas 13 y 17 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n beforeEach (l\u00ednea 9), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 10 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos. Info Estamos usando euros para los ejemplos. En realidad, y dado que TypeScript no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase Moneda o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase Menu vamos a almacenar el valor en c\u00e9ntimos. Para indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo number() que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo price(). Ejecutamos las pruebas y vemos los errores que obtenemos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn test yarn run v1.17.3 $ jest FAIL src/restaurant/menu.spec.ts \u25cf Test suite failed to run TypeScript diagnostics (customize using `[jest-config].globals.ts-jest.diagnostics` option): src/restaurant/menu.spec.ts:10:21 - error TS2554: Expected 0 arguments, but got 2. 10 menu = new Menu(OPTION, PRICE); ~~~~~~~~~~~~~ src/restaurant/menu.spec.ts:14:17 - error TS2339: Property 'option' does not exist on type 'Menu'. 14 expect(menu.option()).toBe(OPTION); ~~~~~~ src/restaurant/menu.spec.ts:18:17 - error TS2339: Property 'price' does not exist on type 'Menu'. 18 expect(menu.price()).toBe(PRICE); ~~~~~ Test Suites: 1 failed, 1 total Tests: 0 total Snapshots: 0 total Time: 2.677s Ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Menu { constructor ( private _option : number , private _price : number ) {} option () : number { return this . _option ; } price () : number { return this . _price ; } } export default Menu ; Ejecutamos las pruebas y comprobamos que pasan: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ yarn test yarn run v1.17.3 $ jest PASS src/restaurant/menu.spec.ts Menu class \u2713 has a menu option number (5ms) \u2713 has a price (1ms) Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 2.737s Ran all test suites. Done in 3.45s. Terminar de implementar los antecedentes \u00b6 Ahora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el fichero step-definitions/menu.steps.ts . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; Before (() => { menus = []; }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( int ) { // When('pido la cuenta recibo una factura de {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Ejecutamos cucumber y vemos que ya hay pruebas que pasan: 1 2 3 4 $ yarn cucumber 5 scenarios (5 pending) 31 steps (5 pending, 21 skipped, 5 passed) 0m00.001s","title":"Crear el proyecto"},{"location":"start-project/#crear-el-proyecto","text":"Vamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de una plantilla ya preparada. Abrimos la siguiente direcci\u00f3n: https://github.com/aulasoftwarelibre/bdd-typescript-template . Y pulsamos el bot\u00f3n \"Use this template\" para crear un nuevo repositorio basado en \u00e9l. Clonamos el repositorio en nuestro equipo e instalamos las dependencias con yarn install .","title":"Crear el proyecto"},{"location":"start-project/#creacion-de-caracteristicas","text":"Las caracter\u00edsticas (ficheros .feature ) deben ir dentro del directorio features/ de nuestro proyecto. Tip Las cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo. Crearemos dentro de dicho directorio un fichero llamado menu.feature con el contenido que describimos en el cap\u00edtulo anterior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos","title":"Creaci\u00f3n de caracter\u00edsticas"},{"location":"start-project/#ejecucion-de-cucumber","text":"Ahora que tenemos las pruebas definidas vamos a ejecutar cucumber : 1 yarn cucumber Obtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n: 1 2 3 5 scenarios ( 5 undefined ) 31 steps ( 31 undefined ) 0m00.000s Lo que significa es que cucumber no reconoce ninguno de los step o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello cucumber nos facilita el trabajo con una serie de snippets . Veamos uno: 1 2 3 4 5 6 7 8 <? php Given ( 'que he comprado {int} men\u00fas del n\u00famero {int}' , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return 'pending' ; }); El step se compone de una cabecera con las palabras Given , When o Then y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa cucumber . Si creamos el archivo step-definitions/menu.steps.ts , lo usaremos para introducir todos los snippets que nos ha generado el int\u00e9rprete. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import { Given , Then , When } from \"cucumber\" ; Given ( \"los siguientes men\u00fas:\" , function ( dataTable ) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( int ) { // When('pido la cuenta recibo una factura de {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Si volvemos a ejecutar behat: 1 yarn cucumber Obtenemos algo distinto: 1 2 3 5 scenarios ( 5 pending ) 31 steps ( 5 pending, 26 skipped ) 0m00.001s Ya los escenarios no est\u00e1n como undefined sino como pending .","title":"Ejecuci\u00f3n de cucumber"},{"location":"start-project/#implementando-el-primer-step","text":"El primer step es el que corresponde con la parte de antecedentes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Que corresponde al siguiente snippet 1 2 3 4 5 6 import { Given , Then , When } from \"cucumber\" ; Given ( \"los siguientes men\u00fas:\" , function ( dataTable ) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Y aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas.","title":"Implementando el primer step"},{"location":"start-project/#jest","text":"Jest es un framework de pruebas para Javascript.Principalmente lo que vamos a indicar con jest es la API de nuestra clase con el resto del dominio. Por el momento, para poder pasar la prueba que falla \"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de jest . Creamos los siguientes ficheros: 1 2 3 4 // src/restaurant/menu.ts class Menu {} export default Menu ; 1 2 3 4 5 6 7 8 9 10 //src/restaurant/menu.spec.ts import Menu from \"./menu\" ; describe ( \"Menu class\" , () => { let menu = new Menu (); it ( \"is initializable\" , () => { expect ( menu ). toBeInstanceOf ( Menu ); }); }); Ejecutamos las pruebas y obtenemos lo siguiente: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ yarn test yarn run v1.17.3 $ jest PASS src/restaurant/menu.spec.ts Menu class \u2713 it is initializable (3ms) Test Suites: 1 passed, 1 total Tests: 1 passed, 1 total Snapshots: 0 total Time: 1.409s, estimated 2s Ran all test suites. Done in 2.01s. Vamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro menu.spec.ts : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import Menu from \"./menu\" ; describe ( \"Menu class\" , () => { const OPTION = 10 ; const PRICE = 2500 ; let menu : Menu ; beforeEach (() => { menu = new Menu ( OPTION , PRICE ); }); it ( \"has a menu option number\" , () => { expect ( menu . option ()). toBe ( OPTION ); }); it ( \"has a price\" , () => { expect ( menu . price ()). toBe ( PRICE ); }); }); Las l\u00edneas 13 y 17 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n beforeEach (l\u00ednea 9), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 10 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos. Info Estamos usando euros para los ejemplos. En realidad, y dado que TypeScript no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase Moneda o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase Menu vamos a almacenar el valor en c\u00e9ntimos. Para indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo number() que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo price(). Ejecutamos las pruebas y vemos los errores que obtenemos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ yarn test yarn run v1.17.3 $ jest FAIL src/restaurant/menu.spec.ts \u25cf Test suite failed to run TypeScript diagnostics (customize using `[jest-config].globals.ts-jest.diagnostics` option): src/restaurant/menu.spec.ts:10:21 - error TS2554: Expected 0 arguments, but got 2. 10 menu = new Menu(OPTION, PRICE); ~~~~~~~~~~~~~ src/restaurant/menu.spec.ts:14:17 - error TS2339: Property 'option' does not exist on type 'Menu'. 14 expect(menu.option()).toBe(OPTION); ~~~~~~ src/restaurant/menu.spec.ts:18:17 - error TS2339: Property 'price' does not exist on type 'Menu'. 18 expect(menu.price()).toBe(PRICE); ~~~~~ Test Suites: 1 failed, 1 total Tests: 0 total Snapshots: 0 total Time: 2.677s Ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Menu { constructor ( private _option : number , private _price : number ) {} option () : number { return this . _option ; } price () : number { return this . _price ; } } export default Menu ; Ejecutamos las pruebas y comprobamos que pasan: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ yarn test yarn run v1.17.3 $ jest PASS src/restaurant/menu.spec.ts Menu class \u2713 has a menu option number (5ms) \u2713 has a price (1ms) Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 2.737s Ran all test suites. Done in 3.45s.","title":"Jest"},{"location":"start-project/#terminar-de-implementar-los-antecedentes","text":"Ahora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el fichero step-definitions/menu.steps.ts . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import { Before , Given , TableDefinition , Then , When } from \"cucumber\" ; import Menu from \"../src/restaurant/menu\" ; let menus : Menu []; Before (() => { menus = []; }); Given ( \"los siguientes men\u00fas:\" , function ( dataTable : TableDefinition ) { dataTable . rows () . forEach ( values => ( menus [ values [ 0 ]] = new Menu ( Number ( values [ 0 ]), 100 * Number ( values [ 1 ]) )) ); }); Given ( \"que he comprado {int} men\u00fas del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fas del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fas del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fas del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pido la cuenta recibo una factura de {int} euros\" , function ( int ) { // When('pido la cuenta recibo una factura de {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago en efectivo con {int} euros\" , function ( int ) { // When('pago en efectivo con {float} euros', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"la factura est\u00e1 pagada\" , function () { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"he obtenido {int} puntos\" , function ( int ) { // Then('he obtenido {float} puntos', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); When ( \"pago con {int} puntos y {int} euros\" , function ( int , int2 ) { // When('pago con {int} puntos y {float} euros', function (int, float) { // When('pago con {float} puntos y {int} euros', function (float, int) { // When('pago con {float} puntos y {float} euros', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Then ( \"quedan {int} euros por pagar\" , function ( int ) { // Then('quedan {float} euros por pagar', function (float) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Given ( \"que he comprado {int} men\u00fa del n\u00famero {int}\" , function ( int , int2 ) { // Given('que he comprado {int} men\u00fa del n\u00famero {float}', function (int, float) { // Given('que he comprado {float} men\u00fa del n\u00famero {int}', function (float, int) { // Given('que he comprado {float} men\u00fa del n\u00famero {float}', function (float, float2) { // Write code here that turns the phrase above into concrete actions return \"pending\" ; }); Ejecutamos cucumber y vemos que ya hay pruebas que pasan: 1 2 3 4 $ yarn cucumber 5 scenarios (5 pending) 31 steps (5 pending, 21 skipped, 5 passed) 0m00.001s","title":"Terminar de implementar los antecedentes"},{"location":"third-scenario/","text":"Tercer escenario \u00b6 Vamos a implementar el tercer escenario 1 2 3 4 5 6 Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si ejecutamos la prueba: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:30 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.003s Done in 1 .88s. \u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos ( steps ), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.","title":"Tercer escenario"},{"location":"third-scenario/#tercer-escenario","text":"Vamos a implementar el tercer escenario 1 2 3 4 5 6 Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si ejecutamos la prueba: 1 2 3 4 5 6 7 $ yarn cucumber features/menu.feature:30 .............. 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m00.003s Done in 1 .88s. \u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos ( steps ), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.","title":"Tercer escenario"}]}